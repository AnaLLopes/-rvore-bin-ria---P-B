// Source code is decompiled from a .class file using FernFlower decompiler.
class BinarySearchTree {
   private Node root = null;

   public BinarySearchTree() {
   }

   public void add(Integer v) {
      Node node = new Node();
      node.element = v;
      node.right = null;
      node.left = null;
      if (this.root == null) {
         this.root = node;
      } else {
         Node current = this.root;

         Node prev;
         label21:
         do {
            do {
               prev = current;
               if (v <= current.element) {
                  current = current.left;
                  continue label21;
               }

               current = current.right;
            } while(current != null);

            prev.right = node;
            return;
         } while(current != null);

         prev.left = node;
      }
   }

   public Node contains(Integer v) {
      if (this.root == null) {
         return null;
      } else {
         Node current = this.root;

         do {
            if (current.element == v) {
               return current;
            }

            if (v < current.element) {
               current = current.left;
            } else {
               current = current.right;
            }
         } while(current != null);

         return null;
      }
   }

   public boolean remove(Integer v) {
      if (this.root == null) {
         return false;
      } else {
         Node current = this.root;
         Node father = this.root;
         boolean child_left = true;

         while(current.element != v) {
            father = current;
            if (v < current.element) {
               current = current.left;
               child_left = true;
            } else {
               current = current.right;
               child_left = false;
            }

            if (current == null) {
               return false;
            }
         }

         if (current.left == null && current.right == null) {
            if (current == this.root) {
               this.root = null;
            } else if (child_left) {
               father.left = null;
            } else {
               father.right = null;
            }
         } else if (current.right == null) {
            if (current == this.root) {
               this.root = current.left;
            } else if (child_left) {
               father.left = current.left;
            } else {
               father.right = current.left;
            }
         } else if (current.left == null) {
            if (current == this.root) {
               this.root = current.right;
            } else if (child_left) {
               father.left = current.right;
            } else {
               father.right = current.right;
            }
         } else {
            Node successor = this.node_successor(current);
            if (current == this.root) {
               this.root = successor;
            } else if (child_left) {
               father.left = successor;
            } else {
               father.right = successor;
            }

            successor.left = current.left;
         }

         return true;
      }
   }

   public Node node_successor(Node node) {
      Node father_successor = node;
      Node successor = node;

      for(Node current = node.left; current != null; current = current.left) {
         father_successor = successor;
         successor = current;
      }

      if (successor != node.right) {
         father_successor.left = successor.right;
         successor.right = node.right;
      }

      return successor;
   }

   void clearTree() {
      this.root = null;
   }

   public void inOrder(Node current) {
      if (current != null) {
         this.inOrder(current.left);
         System.out.print(current.element + " ");
         this.inOrder(current.right);
      }

   }

   public void preOrder(Node current) {
      if (current != null) {
         System.out.print(current.element + " ");
         this.preOrder(current.left);
         this.preOrder(current.right);
      }

   }

   public void posOrder(Node current) {
      if (current != null) {
         this.posOrder(current.left);
         this.posOrder(current.right);
         System.out.print(current.element + " ");
      }

   }

   public int height(Node current) {
      if (current != null && (current.left != null || current.right != null)) {
         return this.height(current.left) > this.height(current.right) ? 1 + this.height(current.left) : 1 + this.height(current.right);
      } else {
         return 0;
      }
   }

   public int countNodes(Node current) {
      return current == null ? 0 : 1 + this.countNodes(current.left) + this.countNodes(current.right);
   }

   public Node getRoot() {
      return this.root;
   }

   public void caminhamentos() {
      System.out.print("\n Caminhamento Central ou Em or (Interfixado): ");
      this.inOrder(this.root);
      System.out.print("\n Exibindo em P\u00f3s-ordem (P\u00f3s-fixado): ");
      this.posOrder(this.root);
      System.out.print("\n Exibindo em Pr\u00e9-ordem (Pr\u00e9-fixado): ");
      this.preOrder(this.root);
   }

   public void treeInfo() {
      System.out.println("Altura da arvore: " + this.height(this.root));
      System.out.println("Quantidade de N\u00f3s: " + this.countNodes(this.root));
   }

   public void printTree() {
      if (this.root != null) {
         TreeFormatter formatter = new TreeFormatter();
         System.out.println(formatter.topDown(this.root));
      } else {
         System.out.println("\u00c1rvore vazia!");
      }

   }
}
